<head>
  <script type="module">
    import { html, svg, render } from "../libs/lit-html.js"
    import { createListener } from "../js/createListener.js";
    import { solveSystem } from "../js/solveSystem.js";

    initInteractiveConstraints(document.body);

    function initInteractiveConstraints(targetEl) {

      // STATE
      const STATE = {
        pts: {
          "a": { x: 0, y: 0 },
          "b": { x: 0,  y: 50 },
          "c": { x: 24,  y: 50 }
        },
        constraints: [
          createDistanceConstraint("a", "b", 60),
          createDistanceConstraint("b", "c", 20),
          {
            eqs: [
              "a_x",
              "a_y",
              // "c_x - a_x",
              // "c_y - b_y"
            ]
          } 
        ],
        fillMap: {
          "a": "red",
          "b": "blue",
          "c": "green"
        },
        lines: [
          ["a", "b"],
          ["b", "c"]
        ]
      }

      const view = (state) => {
        return html`
          <style>
            #constraints {
              width: 400px;
              height: 400px;
              border: 1px solid black;
            }
          </style>
          <svg id="constraints" viewBox="-100 -100 200 200">
            ${state.lines.map(l => drawLine(l))}
            ${Object.entries(state.pts).map(drawPoint)}
          </svg>
        `
      }

      const drawPoint = ([id, pt], index) => svg`<circle handle data-id=${id} cx=${pt.x} cy=${pt.y} r="5" fill=${STATE.fillMap[id]}/>`
      const drawLine = (points) => svg`<polyline stroke="grey" stroke-width="3" fill="none" points=${points.map(p => Object.values(STATE.pts[p]).join(",") ).join(" ")} />`

      const r = () => {
        render(view(STATE), targetEl);
      }

      STATE.r = r;

      r();

      const listen = createListener(targetEl);
      addHandleControl(STATE, listen);

    }

    function addHandleControl(state, listen) {
      let draggingId = "";

      listen("mousedown", "[handle]", e => {
        const id = e.target.dataset.id;
        draggingId = id;
      });

      listen("mousemove", "", e => {
        if (draggingId === "") return

        const svg = e.target.closest("svg");
        if (!svg) return;

        const targetPt = getTransformedCoordinates(e, svg);

        state.pts[draggingId].x = targetPt.x;
        state.pts[draggingId].y = targetPt.y;

        const constraints = state.constraints.map(x => x.eqs).flat();

        const initialVals = {};

        Object.entries(state.pts).forEach(([id, pt]) => {
          initialVals[`${id}_x`] = pt.x;
          initialVals[`${id}_y`] = pt.y;
        })

        const [ satisfied, solutions ] = solveSystem(constraints, initialVals);
        
        Object.entries(solutions).forEach(([id, val]) => {
          const [ptId, xy] = id.split("_");
          state.pts[ptId][xy] = val;
        })

        state.r();
      });

      listen("mouseup", "", e => {
        if (draggingId === "") return

        const id = e.target.dataset.id;
        draggingId = "";
      });
    }

    function getTransformedCoordinates(event, svg) {
      let pt = svg.createSVGPoint();

      // Pass event coordinates to the point
      pt.x = event.clientX;
      pt.y = event.clientY;

      // Transform the point into the SVG coordinate system
      let svgPoint = pt.matrixTransform(svg.getScreenCTM().inverse());

      return { x: svgPoint.x, y: svgPoint.y };
    }


    function createDistanceConstraint(p0, p1, dist) {
      const p0x = `${p0}_x`;
      const p1x = `${p1}_x`;
      const p0y = `${p0}_y`;
      const p1y = `${p1}_y`;

      return {
        name: "distance",
        points: [p0, p1],
        dist: dist,
        eqs: [`${dist} - sqrt((${p1x}-${p0x})^2+(${p1y}-${p0y})^2)`]
      }
    }
  </script>
</head>
<body>
</body>














